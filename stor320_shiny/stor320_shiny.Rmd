---
title: "STOR 320 Shiny"
author: | 
  | Frances Tong
  | Data Scientist
  | BD Technologies & Innovation
  | 
  | Talk URL
  | [https://francestong.shinyapps.io/stor320_shiny/](https://francestong.shinyapps.io/stor320_shiny/)
  | Code of talk 
  | [https://github.com/francestong/stor390/tree/master/stor320_shiny/stor320_shiny.Rmd](https://github.com/francestong/stor390/tree/master/stor320_shiny/stor320_shiny.Rmd)
runtime: shiny
output: slidy_presentation
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

## Who am I?

* PhD in statistics
* Analysis of genomic data 
* [list kinds of projects]
* Demo of company app

## Topics today

[list topics]
[include link to jump there]

**All the app examples in this lecture are complete - you should be able to copy and paste the provided code into R console and have the app work.**
**Reload the page if any app in a slide doesn't appear to be working**

## renderUI 

One of the more powerful render functions is renderUI() - it enables us to 
generate dynamic UI, i.e. construct reactive objects that depend on user input. 
We illustrate how it works with a toy example that requires this function.

Let's say we are selecting colors for plotting in R, and we want to help the 
user narrow down the choices through color families.

If the user wants a red color, then the drop-down menu can display only the
red options.  We can't put a `selectInput` drop down menu in **ui** when we 
can't populate the choices argument with the correct list of colors that 
depend on what the user chooses in the `radioButtons`.  This means that we need 
to dynamically generate this `selectInput` inside `renderUI` (on the **server** side!)
based on the user-chosen color family `input$color_family`.

## renderUI example

```{r}
color_list <- list(red = c("tomato", "violetred", "firebrick"),
                   green = c("chartreuse", "forestgreen", "olivedrab"),
                   blue = c("navy", "dodgerblue", "torquoise"))

inputPanel(
  radioButtons(inputId = "color_family",
               label = "Choose a color family",
               choices = c("red", "green", "blue"))
)

renderUI({
  selectInput(inputId = "color",
              label = "Select color",
              choices = color_list[input$color_family])
})

renderText({
  paste("You chose this color:", input$color)
})
```


## renderUI example code

```{r, echo=TRUE, eval=FALSE}
library(shiny)

color_list <- list(red = c("tomato", "violetred", "firebrick"),
                   green = c("chartreuse", "forestgreen", "olivedrab"),
                   blue = c("navy", "dodgerblue", "torquoise"))

ui <- fluidPage(
    
    radioButtons(inputId = "color_family",
                 label = "Choose a color family",
                 choices = c("red", "green", "blue")),
    
    uiOutput(outputId = "color_selector"),
    
    verbatimTextOutput(outputId = "color_chosen")
    
)

server <- function(input, output) {
    
    output$color_selector <- renderUI({
        
        selectInput(inputId = "color",
                    label = "Select color",
                    choices = color_list[input$color_family])
        
    })
        
    output$color_chosen <- renderText({
        paste("You chose this color:", input$color)
    })
    
    
}

shinyApp(ui = ui, server = server)
```



## Reactive expressions

Reactive expressions are a way for your app to update efficiently when users
interact with it.  They are a bit nuanced to use - here's the RStudio tutorial on them https://shiny.rstudio.com/tutorial/lesson6/. 

In general, any code you put in a `render` function will continually be updated, 
even if you don't necessarily need them to be rerun every single time.  This will
slow down your app considerably.  If you want to use data inside a `render` function
that does not need to be updated every time if `input` doesn't change, 
then you can wrap your data inside a reactive expression that can be called inside `render`.
The reactive expression will only recalculate if `input` has changed.


- Reactive expressions depend on the status of `input` values or values from other reactive expressions.
- You can create reactive expressions with `reactive({})`.
- You can access a reactive expression with its name followed by `()`.
- You can only call a reactive expression within a `reactive` or `render` function.

## Reactive expression example

```{r, eval=TRUE, echo=FALSE}
inputPanel(
  
  sliderInput(inputId = "rate",
              label = "Choose rate",
              min = 0,
              max = 1, 
              value = 0.5),
  
  textOutput(outputId = "pct_std"),
  
  textOutput(outputId = "pct_half")
)

my_percent <- reactive({
  input$rate * 100
})

my_half_percent <- reactive({
  my_percent() / 2
})

renderText({
  paste0("This is my percent: ", my_percent(), "%")
})

renderText({
  paste0("This is my percent by half: ", my_half_percent(), "%")
})
```


## Reactive expression example code

```{r, eval=FALSE, echo=TRUE}
library(shiny)

ui <- fluidPage(
    
    sliderInput(inputId = "rate",
                label = "Choose rate",
                min = 0,
                max = 1, 
                value = 0.5),
    
    textOutput(outputId = "pct_std"),
    
    textOutput(outputId = "pct_half")
    
)

server <- function(input, output) {
    
    my_percent <- reactive({
        input$rate * 100
    })
    
    my_half_percent <- reactive({
        my_percent() / 2
    })
    
    output$pct_std <- renderText({
        paste0("This is my percent: ", my_percent(), "%")
    })
    
    output$pct_half <- renderText({
        paste0("This is my percent by half: ", my_half_percent(), "%")
    })
    
}

shinyApp(ui = ui, server = server)
```

## Interactive visualization

There are several well-developed packages for generating interactive
graphics in a Shiny app:

- [Shiny built-in support for interacting with static plots](https://shiny.rstudio.com/articles/plot-interaction.html)
- [plotly](https://plot.ly/)
- [Leaflet](https://rstudio.github.io/leaflet/shiny.html) for interactive maps
- [htmlwidgets for R](http://www.htmlwidgets.org/) - use JavaScript visualization libraries & [Crosstalk](http://rstudio.github.io/crosstalk/) - add-on to htmlwidgets
- [ggvis](http://ggvis.rstudio.com/interactivity.html)


## Plotly example

```{r, echo=FALSE, eval=TRUE}
library(plotly)

renderPlotly({
  plot_ly(x = rnorm(10), y = rnorm(10), z = rnorm(10)) %>% 
    add_markers()
})

renderPrint({
  d <- event_data("plotly_hover")
  if (is.null(d)) "Hover events appear here (unhover to clear)" else d
})

renderPrint({
  d <- event_data("plotly_click")
  if (is.null(d)) "Click events appear here (double-click to clear)" else d
})
```


## Plotly example code

```{r, eval=FALSE, echo=TRUE}
library(plotly)
library(shiny)

ui <- fluidPage(
  plotlyOutput("plot"),
  verbatimTextOutput("hover"),
  verbatimTextOutput("click")
)

server <- function(input, output) {

  output$plot <- renderPlotly({
    plot_ly(x = rnorm(10), y = rnorm(10), z = rnorm(10)) %>% 
          add_markers()
  })

  output$hover <- renderPrint({
    d <- event_data("plotly_hover")
    if (is.null(d)) "Hover events appear here (unhover to clear)" else d
  })

  output$click <- renderPrint({
    d <- event_data("plotly_click")
    if (is.null(d)) "Click events appear here (double-click to clear)" else d
  })

}

shinyApp(ui, server)
```

## Leaflet example

```{r}
library(leaflet)


inputPanel(
  # numericInput("lat", "Latitude", value = 35.891681),
  # numericInput("lng", "Longitude", value = -78.8608968),
  # textInput("label", "Place", value = "BD Technologies & Innovation")
  numericInput("lat", "Latitude", value = 35.910274),
  numericInput("lng", "Longitude", value = -79.051004),
  textInput("label", "Place", value = "You are here!")
)

renderLeaflet({
  leaflet() %>%
    addTiles() %>%  # Add default OpenStreetMap map tiles
    addMarkers(lng = input$lng, lat = input$lat, popup = input$label)
})
```


## Leaflet example code

```{r, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE}
library(shiny)
library(leaflet)

ui <- fluidPage(
  numericInput("lat", "Latitude", value = 35.910274),
  numericInput("lng", "Longitude", value = -79.051004),
  textInput("label", "Place", value = "You are here!")
  leafletOutput("mymap")
)

server <- function(input, output) {
  output$mymap <- renderLeaflet({
    leaflet() %>%
      addTiles() %>%  # Add default OpenStreetMap map tiles
      addMarkers(lng = input$lng, lat = input$lat, popup = input$label)
  })
}

shinyApp(ui, server)
```


## DataTables

The Javascript library DataTables provides very powerful functionality to 
working with data tables in a web browser.  Shiny apps can tap this through 
the R package [DT](https://rstudio.github.io/DT/) that interfaces with DataTables.  

Some of the useful things implemented are:

- selecting rows in the table
- search capabilities
- sorting columns
- filter columns
- showing user-specified number of rows
- styling such as highlighting and formatting

## DataTables example

Here's a minimal example that you can run in the R console:

```{r, eval=TRUE, echo=TRUE}
library(DT)
datatable(iris)
```

Here's how that table gets into a Shiny app:

```{r, eval=FALSE, echo=TRUE}
library(shiny)

ui <- fluidPage(
    DT::dataTableOutput('tbl')
)

server <- function(input, output) {
    output$tbl = DT::renderDataTable(
        iris
    )
}

shinyApp(ui, server)
```



## Dynamic document generation (pdf/html/word)

You can enable users to dynamically compile Rmarkdown into documents that he/she can then download.
For example, a scientist can choose an experiment from a table in an app, look at the
results in different kinds of plots, and then select certain plots to be included in 
an official report generated by the app.

Here's an example that takes a name and uses that as the author of a report. 
You'll notice that it needs a rmarkdown template to fill in the user inputs and compile.  The header of the file `report.Rmd` looks like:

```{r echo=TRUE, eval=FALSE}
---
title: "My Report"
author: "`r input$user_name`"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: html_document
---
```

_For now this example doesn't work when hosted on shinyapps.io: copy and paste the code on the following slide along with a `report.Rmd` in the same directory._

```{r, echo=FALSE, eval=TRUE}
inputPanel(
     textInput(inputId = 'user_name',
              label = 'Name'),
    
    radioButtons(inputId = 'format', 
                 label = 'Run Report Format', 
                 c('PDF', 'HTML', 'Word'),
                 inline = TRUE),
    
    downloadButton('generate_report')
)

downloadHandler(
        
        filename = function() {
            
            paste0("my_report", ".",
                   switch(
                       input$format, PDF = 'pdf', HTML = 'html', Word = 'docx'
                   ))
            
        },
        
        content = function(file) {
            
            markdownFile <- 'report.Rmd'
            src <- normalizePath(markdownFile)

            owd <- setwd(tempdir())
            on.exit(setwd(owd))
            file.copy(src, markdownFile, overwrite = TRUE)

            out <- render(markdownFile, switch(
                input$format,
                PDF = pdf_document(), HTML = html_document(), Word = word_document()
            ))
            file.rename(out, file)
            
        }
    )
    
```


## Dynamic document generation example code


```{r, eval=FALSE, echo=TRUE}
library(shiny)
library(rmarkdown)

ui <- fluidPage(
    
    textInput(inputId = 'user_name',
              label = 'Name'),
    
    radioButtons(inputId = 'format', 
                 label = 'Run Report Format', 
                 c('PDF', 'HTML', 'Word'),
                 inline = TRUE),
    
    downloadButton('generate_report')
    
)

server <- function(input, output) {
    
    output$generate_report <- downloadHandler(
        
        filename = function() {
            
            paste0("my_report", ".",
                   switch(
                       input$format, PDF = 'pdf', HTML = 'html', Word = 'docx'
                   ))
            
        },
        
        content = function(file) {
            
            markdownFile <- 'report.Rmd'
            src <- normalizePath(markdownFile)

            owd <- setwd(tempdir())
            on.exit(setwd(owd))
            file.copy(src, markdownFile, overwrite = TRUE)

            out <- render(markdownFile, switch(
                input$format,
                PDF = pdf_document(), HTML = html_document(), Word = word_document()
            ))
            file.rename(out, file)
            
        }
    )
    
}

shinyApp(ui = ui, server = server)
```


