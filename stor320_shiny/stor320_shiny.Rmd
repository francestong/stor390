---
title: "STOR 320 Shiny"
author: | 
  | Frances Tong
  | frances.p.tong@gmail.com
  | Data Scientist @ BD Technologies & Innovation
  | 
  | Talk URL
  | [https://francestong.shinyapps.io/stor320_shiny/](https://francestong.shinyapps.io/stor320_shiny/)
  | Code of talk 
  | [https://github.com/francestong/stor390/tree/master/stor320_shiny/stor320_shiny.Rmd](https://github.com/francestong/stor390/tree/master/stor320_shiny/stor320_shiny.Rmd)
runtime: shiny
output: slidy_presentation
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

## Who am I?

* PhD in statistics
* Analysis of genomic data 
* [list kinds of projects]
* Demo of company app

## R community in this area


**R Ladies**


## Topics today - April 15, 2019

This lecture is an introduction to Shiny and contains the basics that you 
already learned at last Friday's lecture that you can reference later if you like.
Today we will go into more advanced Shiny topics and skip ahead to those slides.

* renderUI
* interactive visualization
* DataTables
* dynamic document generation
* modules


**All the app examples in this lecture are complete - you should be able to copy and paste the provided code into R console and have the app work.**

**Reload the page if any app in a slide doesn't appear to be working**


## Introduction to Shiny

You can make interactive web applications easily and entirely in R with Shiny.
Shiny apps are a great way to share your analysis with others without them having to 
run any R themselves.


This lecture will cover 

- first Shiny app
- the basics of reactivity
- renderUI
- app layouts
- interactive visualization
- extra: 
    - DataTables
    - pdf/html/word generation
    - modules
    - hosting apps


## renderUI 

One of the more powerful render functions is renderUI() - it enables us to 
generate dynamic UI, i.e. construct reactive objects that depend on user input. 
We illustrate how it works with a toy example that requires this function.

Let's say we are selecting colors for plotting in R, and we want to help the 
user narrow down the choices through color families.

If the user wants a red color, then the drop-down menu can display only the
red options.  We can't put a `selectInput` drop down menu in **ui** when we 
can't populate the choices argument with the correct list of colors that 
depend on what the user chooses in the `radioButtons`.  This means that we need 
to dynamically generate this `selectInput` inside `renderUI` (on the **server** side!)
based on the user-chosen color family `input$color_family`.

## renderUI example

```{r}
color_list <- list(red = c("tomato", "violetred", "firebrick"),
                   green = c("chartreuse", "forestgreen", "olivedrab"),
                   blue = c("navy", "dodgerblue", "torquoise"))

inputPanel(
  radioButtons(inputId = "color_family",
               label = "Choose a color family",
               choices = c("red", "green", "blue"))
)

renderUI({
  selectInput(inputId = "color",
              label = "Select color",
              choices = color_list[input$color_family])
})

renderText({
  paste("You chose this color:", input$color)
})
```


## renderUI example code

```{r, echo=TRUE, eval=FALSE}
library(shiny)

color_list <- list(red = c("tomato", "violetred", "firebrick"),
                   green = c("chartreuse", "forestgreen", "olivedrab"),
                   blue = c("navy", "dodgerblue", "torquoise"))

ui <- fluidPage(
    
    radioButtons(inputId = "color_family",
                 label = "Choose a color family",
                 choices = c("red", "green", "blue")),
    
    uiOutput(outputId = "color_selector"),
    
    verbatimTextOutput(outputId = "color_chosen")
    
)

server <- function(input, output) {
    
    output$color_selector <- renderUI({
        
        selectInput(inputId = "color",
                    label = "Select color",
                    choices = color_list[input$color_family])
        
    })
        
    output$color_chosen <- renderText({
        paste("You chose this color:", input$color)
    })
    
    
}

shinyApp(ui = ui, server = server)
```



## Reactive expressions

Reactive expressions are a way for your app to update efficiently when users
interact with it.  They are a bit nuanced to use - here's the RStudio tutorial on them https://shiny.rstudio.com/tutorial/lesson6/. 

In general, any code you put in a `render` function will continually be updated, 
even if you don't necessarily need them to be rerun every single time.  This will
slow down your app considerably.  If you want to use data inside a `render` function
that does not need to be updated every time if `input` doesn't change, 
then you can wrap your data inside a reactive expression that can be called inside `render`.
The reactive expression will only recalculate if `input` has changed.


- Reactive expressions depend on the status of `input` values or values from other reactive expressions.
- You can create reactive expressions with `reactive({})`.
- You can access a reactive expression with its name followed by `()`.
- You can only call a reactive expression within a `reactive` or `render` function.

## Reactive expression example

```{r, eval=TRUE, echo=FALSE}
inputPanel(
  
  sliderInput(inputId = "rate",
              label = "Choose rate",
              min = 0,
              max = 1, 
              value = 0.5),
  
  textOutput(outputId = "pct_std"),
  
  textOutput(outputId = "pct_half")
)

my_percent <- reactive({
  input$rate * 100
})

my_half_percent <- reactive({
  my_percent() / 2
})

renderText({
  paste0("This is my percent: ", my_percent(), "%")
})

renderText({
  paste0("This is my percent by half: ", my_half_percent(), "%")
})
```


## Reactive expression example code

```{r, eval=FALSE, echo=TRUE}
library(shiny)

ui <- fluidPage(
    
    sliderInput(inputId = "rate",
                label = "Choose rate",
                min = 0,
                max = 1, 
                value = 0.5),
    
    textOutput(outputId = "pct_std"),
    
    textOutput(outputId = "pct_half")
    
)

server <- function(input, output) {
    
    my_percent <- reactive({
        input$rate * 100
    })
    
    my_half_percent <- reactive({
        my_percent() / 2
    })
    
    output$pct_std <- renderText({
        paste0("This is my percent: ", my_percent(), "%")
    })
    
    output$pct_half <- renderText({
        paste0("This is my percent by half: ", my_half_percent(), "%")
    })
    
}

shinyApp(ui = ui, server = server)
```

## Interactive visualization

There are several well-developed packages for generating interactive
graphics in a Shiny app:

- [Shiny built-in support for interacting with static plots](https://shiny.rstudio.com/articles/plot-interaction.html)
- [plotly](https://plot.ly/)
- [Leaflet](https://rstudio.github.io/leaflet/shiny.html) for interactive maps
- [htmlwidgets for R](http://www.htmlwidgets.org/) - use JavaScript visualization libraries & [Crosstalk](http://rstudio.github.io/crosstalk/) - add-on to htmlwidgets
- [ggvis](http://ggvis.rstudio.com/interactivity.html)


## Plotly example

```{r, echo=FALSE, eval=TRUE}
library(plotly)

renderPlotly({
  plot_ly(x = rnorm(10), y = rnorm(10), z = rnorm(10)) %>% 
    add_markers()
})

renderPrint({
  d <- event_data("plotly_hover")
  if (is.null(d)) "Hover events appear here (unhover to clear)" else d
})

renderPrint({
  d <- event_data("plotly_click")
  if (is.null(d)) "Click events appear here (double-click to clear)" else d
})
```


## Plotly example code

```{r, eval=FALSE, echo=TRUE}
library(plotly)
library(shiny)

ui <- fluidPage(
  plotlyOutput("plot"),
  verbatimTextOutput("hover"),
  verbatimTextOutput("click")
)

server <- function(input, output) {

  output$plot <- renderPlotly({
    plot_ly(x = rnorm(10), y = rnorm(10), z = rnorm(10)) %>% 
          add_markers()
  })

  output$hover <- renderPrint({
    d <- event_data("plotly_hover")
    if (is.null(d)) "Hover events appear here (unhover to clear)" else d
  })

  output$click <- renderPrint({
    d <- event_data("plotly_click")
    if (is.null(d)) "Click events appear here (double-click to clear)" else d
  })

}

shinyApp(ui, server)
```

## Leaflet example

```{r}
library(leaflet)


inputPanel(
  # numericInput("lat", "Latitude", value = 35.891681),
  # numericInput("lng", "Longitude", value = -78.8608968),
  # textInput("label", "Place", value = "BD Technologies & Innovation")
  numericInput("lat", "Latitude", value = 35.910274),
  numericInput("lng", "Longitude", value = -79.051004),
  textInput("label", "Place", value = "You are here!")
)

renderLeaflet({
  leaflet() %>%
    addTiles() %>%  # Add default OpenStreetMap map tiles
    addMarkers(lng = input$lng, lat = input$lat, popup = input$label)
})
```


## Leaflet example code

```{r, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE}
library(shiny)
library(leaflet)

ui <- fluidPage(
  numericInput("lat", "Latitude", value = 35.910274),
  numericInput("lng", "Longitude", value = -79.051004),
  textInput("label", "Place", value = "You are here!")
  leafletOutput("mymap")
)

server <- function(input, output) {
  output$mymap <- renderLeaflet({
    leaflet() %>%
      addTiles() %>%  # Add default OpenStreetMap map tiles
      addMarkers(lng = input$lng, lat = input$lat, popup = input$label)
  })
}

shinyApp(ui, server)
```


## DataTables

The Javascript library DataTables provides very powerful functionality to 
working with data tables in a web browser.  Shiny apps can tap this through 
the R package [DT](https://rstudio.github.io/DT/) that interfaces with DataTables.  

Some of the useful things implemented are:

- selecting rows in the table
- search capabilities
- sorting columns
- filter columns
- showing user-specified number of rows
- styling such as highlighting and formatting

## DataTables example

Here's a minimal example that you can run in the R console:

```{r, eval=TRUE, echo=TRUE}
library(DT)
datatable(iris)
```

Here's how that table gets into a Shiny app:

```{r, eval=FALSE, echo=TRUE}
library(shiny)

ui <- fluidPage(
    DT::dataTableOutput('tbl')
)

server <- function(input, output) {
    output$tbl = DT::renderDataTable(
        iris
    )
}

shinyApp(ui, server)
```



## Dynamic document generation (pdf/html/word)

You can enable users to dynamically compile Rmarkdown into documents that he/she can then download.
For example, a scientist can choose an experiment from a table in an app, look at the
results in different kinds of plots, and then select certain plots to be included in 
an official report generated by the app.

Here's an example that takes a name and uses that as the author of a report. 
You'll notice that it needs a rmarkdown template to fill in the user inputs and compile.  The file `report.Rmd` looks like the following - the header includes R chunks to fill in the author and date.

```{r echo=TRUE, eval=FALSE}
---
title: "My Report"
author: "`r input$user_name`"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: html_document
---
  
Hello World!
```

_For now this example doesn't work when hosted on shinyapps.io: copy and paste the code on the following slide along with a `report.Rmd` in the same directory._

```{r, echo=FALSE, eval=TRUE}
inputPanel(
     textInput(inputId = 'user_name',
              label = 'Name'),
    
    radioButtons(inputId = 'format', 
                 label = 'Run Report Format', 
                 c('PDF', 'HTML', 'Word'),
                 inline = TRUE),
    
    downloadButton('generate_report')
)

downloadHandler(
        
        filename = function() {
            
            paste0("my_report", ".",
                   switch(
                       input$format, PDF = 'pdf', HTML = 'html', Word = 'docx'
                   ))
            
        },
        
        content = function(file) {
            
            markdownFile <- 'report.Rmd'
            src <- normalizePath(markdownFile)

            owd <- setwd(tempdir())
            on.exit(setwd(owd))
            file.copy(src, markdownFile, overwrite = TRUE)

            out <- render(markdownFile, switch(
                input$format,
                PDF = pdf_document(), HTML = html_document(), Word = word_document()
            ))
            file.rename(out, file)
            
        }
    )
    
```





## Dynamic document generation example code


```{r, eval=FALSE, echo=TRUE}
library(shiny)
library(rmarkdown)

ui <- fluidPage(
    
    textInput(inputId = 'user_name',
              label = 'Name'),
    
    radioButtons(inputId = 'format', 
                 label = 'Run Report Format', 
                 c('PDF', 'HTML', 'Word'),
                 inline = TRUE),
    
    downloadButton('generate_report')
    
)

server <- function(input, output) {
    
    output$generate_report <- downloadHandler(
        
        filename = function() {
            
            paste0("my_report", ".",
                   switch(
                       input$format, PDF = 'pdf', HTML = 'html', Word = 'docx'
                   ))
            
        },
        
        content = function(file) {
            
            markdownFile <- 'report.Rmd'
            src <- normalizePath(markdownFile)

            owd <- setwd(tempdir())
            on.exit(setwd(owd))
            file.copy(src, markdownFile, overwrite = TRUE)

            out <- render(markdownFile, switch(
                input$format,
                PDF = pdf_document(), HTML = html_document(), Word = word_document()
            ))
            file.rename(out, file)
            
        }
    )
    
}

shinyApp(ui = ui, server = server)
```





## Shiny modules

Large and complex Shiny apps will have many many lines of code.  Having it all
in just one or two files can get very disorganized and unreadable, and sometimes you have parts that look very similar and redundant.  Just like how we modularize reusable R code into functions or packages, we can modularize Shiny code into [Shiny modules](https://shiny.rstudio.com/articles/modules.html)!

You can construct a Shiny module with two functions - one for the UI and one for the
server.  

This lecture won't go into detail on how it works - it can get complicated but
here's a simple module on the next slide.


## Shiny module example


```{r, eval=TRUE, echo=FALSE}
linkedScatterUI <- function(id) {
  ns <- NS(id)
  
  fluidRow(
    column(6, plotOutput(ns("plot1"), brush = ns("brush"))),
    column(6, plotOutput(ns("plot2"), brush = ns("brush")))
  )
}

linkedScatter <- function(input, output, session, data, left, right) {
  # Yields the data frame with an additional column "selected_"
  # that indicates whether that observation is brushed
  dataWithSelection <- reactive({
    brushedPoints(data(), input$brush, allRows = TRUE)
  })
  
  output$plot1 <- renderPlot({
    scatterPlot(dataWithSelection(), left())
  })
  
  output$plot2 <- renderPlot({
    scatterPlot(dataWithSelection(), right())
  })
  
  return(dataWithSelection)
}

scatterPlot <- function(data, cols) {
  ggplot(data, aes_string(x = cols[1], y = cols[2])) +
    geom_point(aes(color = selected_)) +
    scale_color_manual(values = c("black", "#66D65C"), guide = FALSE)
}


linkedScatterUI("scatters")
textOutput("summary")

df <- callModule(linkedScatter, "scatters", reactive(mpg),
                 left = reactive(c("cty", "hwy")),
                 right = reactive(c("drv", "hwy"))
)

renderText({
  sprintf("%d observation(s) selected", nrow(dplyr::filter(df(), selected_)))
})
```


## Shiny module example code


Some key points:

- `linkedScatter` is the module - `linkedScatterUI()` specifies the UI, `linkedScatter()` specifies the server part of the module (this requires the `session` argument after `input` and `output`).
- You use `callModule()` to call the module in the main server part.
- Object ids need to be wrapped with the namespace function (`NS()`) in the module so that it enforces unique ids across the entire app.
- You can return things with a module and supply it as an input into another module.



```{r, eval=FALSE, echo=TRUE}
library(shiny)

linkedScatterUI <- function(id) {
    ns <- NS(id)
    
    fluidRow(
        column(6, plotOutput(ns("plot1"), brush = ns("brush"))),
        column(6, plotOutput(ns("plot2"), brush = ns("brush")))
    )
}

linkedScatter <- function(input, output, session, data, left, right) {
    # Yields the data frame with an additional column "selected_"
    # that indicates whether that observation is brushed
    dataWithSelection <- reactive({
        brushedPoints(data(), input$brush, allRows = TRUE)
    })
    
    output$plot1 <- renderPlot({
        scatterPlot(dataWithSelection(), left())
    })
    
    output$plot2 <- renderPlot({
        scatterPlot(dataWithSelection(), right())
    })
    
    return(dataWithSelection)
}

scatterPlot <- function(data, cols) {
    ggplot(data, aes_string(x = cols[1], y = cols[2])) +
        geom_point(aes(color = selected_)) +
        scale_color_manual(values = c("black", "#66D65C"), guide = FALSE)
}


ui <- fixedPage(
    h2("Module example"),
    linkedScatterUI("scatters"),
    textOutput("summary")
)

server <- function(input, output, session) {
    df <- callModule(linkedScatter, "scatters", reactive(mpg),
                     left = reactive(c("cty", "hwy")),
                     right = reactive(c("drv", "hwy"))
    )
    
    output$summary <- renderText({
        sprintf("%d observation(s) selected", nrow(dplyr::filter(df(), selected_)))
    })
}

shinyApp(ui, server)
```



## Hosting apps 

Once you've made your awesome Shiny app, how do you share it with world or at 
least the people you've designed it for? Remember that apps are great because
the user does not need to download and install R or know any R code whatsoever 
to be able to use them.  But this means that the app has to be hosted somewhere 
that does have R, shiny, and all the required packages installed.  

The easiest way to host your app is to have RStudio host it for you at [https://www.shinyapps.io/](https://www.shinyapps.io/).  The pros are that you
don't have to worry about any IT infrastructure in maintaining your own server;
but if your app processes sensitive or confidential data or you don't want the
public to be able to access it, then you either have to pay RStudio for more 
capabilities over the free version or deploy apps yourself with [Shiny Server](https://www.rstudio.com/products/shiny/shiny-server/) - locally or on the cloud.



## Additional materials

* [RStudio Shiny Articles](https://shiny.rstudio.com/articles/)
* [RStudio Shiny Cheatsheet](https://github.com/rstudio/cheatsheets/raw/master/shiny.pdf)
* [RStudio Teach Yourself Shiny](https://shiny.rstudio.com/tutorial/)
* [RStudio Webinar - How to start with Shiny – Part 1](https://www.rstudio.com/resources/webinars/how-to-start-with-shiny-part-1/)
* [RStudio Shiny Examples](https://github.com/rstudio/shiny-examples)
* [Show Me Shiny App Gallery](https://www.showmeshiny.com/)
* [Building Shiny apps - an interactive tutorial](http://deanattali.com/blog/building-shiny-apps-tutorial/)
* [RStudio Reactivity Tutorial](https://github.com/rstudio/reactivity-tutorial)
* [Plotly Shiny Gallery](https://plot.ly/r/shiny-gallery/)
* [Persistent data storage](https://shiny.rstudio.com/articles/persistent-data-storage.html)
* [RStudio Reactivity Overview](https://shiny.rstudio.com/articles/reactivity-overview.html)
* [RStudio Understanding Shiny Modules Webinar](https://www.rstudio.com/resources/webinars/understanding-shiny-modules/)

