---
title: "**Shiny**"
subtitle: "Introduction to web application development with Shiny"
author: "[STOR 390](https://idc9.github.io/stor390/)"
output:
  html_document:
    css: styles.css
    theme: cosmo
    toc: yes
    toc_float: yes
---

```{r setup, include=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
```


You can make interactive web applications easily and entirely in R with Shiny.
Shiny apps are a great way to share your analysis with others without them having to 
run any R themselves.


This lecture will cover (**list in progress**)

- first Shiny app
- beer to burpees app
- the basics of reactivity
- renderUI
- interactive visualization
- advanced: 
    - file uploading & downloading
    - pdf/html/word generation
    - database connection
    - modules


.


# **Hello Shiny!**

Running the code below in the R console will start up a simple Shiny app that
plots a histogram and lets the user choose the number of bins in the histogram 
using a slider.  The code that powers the app is included, and relevant parts 
of the code will be highlighted yellow as you interact with the app.


```{r, eval=FALSE}
if (!require('shiny')) install.packages("shiny")
runExample("01_hello")
```


![](hello_shiny_screenshot.jpeg)



# **Key components of a Shiny app**

A Shiny app is composed of two fundamental parts:

- **ui** - This codes the __user interface__ that controls the layout and appearance of the app.
- **server** - This codes the computations and plots that show up in the user interface.

## File structure

These two parts can either be included in one file called **app.R** or 
in two separate files called **ui.R** and **server.R**.  Both methods work
equivalently, and it's a matter of preference which one you choose and may 
depend on if your app is very short or long.

This is the bare minimum code (it does nothing - a blank page shows up) 
if the app is on one **app.R** file:

```{r, eval=FALSE}
library(shiny)

ui <- fluidPage()

server <- function(input, output) {}

shinyApp(ui = ui, server = server)
```

For two separate files, **ui.R** will contain

```{r, eval=FALSE}
library(shiny)

shinyUI(fluidPage(
))
```

and **server.R** has

```{r, eval=FALSE}
library(shiny)

shinyServer(function(input, output) {
})
```

If the two files are stored in a directory called `my_app`, then you can run the
app with:

```{r, eval=FALSE}
runApp("my_app")
```

Extra: if you want your code to show up alongside your app like in the example, 
then change the display mode to `showcase`.

```{r}
runApp("my_app", display.mode = "showcase")
```




# **Basics of reactivity**

The coolness of Shiny apps comes from its use of reactivity.  This means that 
your apps come alive when you build reactive objects that interact with the user.

You construct a reactive object in two parts:

- **ui**: In the user-interface or ui part of your code, specify the type of object you want to include.
This can be an _input_ object like a checkbox, drop-down menu or even a spreadsheet, 
or an _output_ object like a plot, a table or just text display.
- **server**: In the server part of your code, you code this object up.


Here's the same example as before (with the histogram code rewritten with ggplot2).

In the **ui** section below, there is an input object `sliderInput` that codes for 
a slider that the user can use to choose the number of bins in the histogram,
and there's an output object `plotObject` that displays the histogram.

In the **server** section below, the code that generates the histogram is 
returned in a `renderPlot` function that is saved to the `output` vector under
the same outputId `distPlot` as specified in `plotOutput`.  The user-supplied number of
bins from the slider is available in the `input` vector under the same inputId `bins`
as in `sliderInput`.

```{r}
library(shiny)

ui <- fluidPage(
    
    titlePanel("Hello Shiny!"),
    
    # Sidebar with a slider input for the number of bins
    sidebarLayout(
        sidebarPanel(
            sliderInput(inputId = "bins",
                        label = "Number of bins:",
                        min = 1,
                        max = 50,
                        value = 30)
        ),
        
        # Show a plot of the generated distribution
        mainPanel(
            plotOutput(outputId = "distPlot")
        )
    )
    
)

server <- function(input, output) {
    
    # Expression that generates a histogram. The expression is
    # wrapped in a call to renderPlot to indicate that:
    #
    #  1) It is "reactive" and therefore should be automatically
    #     re-executed when inputs change
    #  2) Its output type is a plot
    
    output$distPlot <- renderPlot({
        
        ggplot(faithful, aes(x = waiting)) +
            geom_histogram(bins = input$bins, colour = "white")
        
    })
    
}

shinyApp(ui = ui, server = server)
```






# **App layout**






# **Additional materials**

* [RStudio Teach Yourself Shiny](https://shiny.rstudio.com/tutorial/)
* [RStudio Webinar - How to start with Shiny â€“ Part 1](https://www.rstudio.com/resources/webinars/how-to-start-with-shiny-part-1/)
* [RStudio Shiny Examples](https://github.com/rstudio/shiny-examples)
* [Show Me Shiny App Gallery](https://www.showmeshiny.com/)
* [Building Shiny apps - an interactive tutorial](http://deanattali.com/blog/building-shiny-apps-tutorial/)
* [RStudio Reactivity Tutorial](https://github.com/rstudio/reactivity-tutorial)







